// This header is not part of the public interface;
// include "rs-sci/random.hpp" instead.

#pragma once

#include "rs-sci/random-continuous-distributions.hpp"
#include "rs-sci/rational.hpp"
#include <cmath>
#include <limits>
#include <type_traits>

namespace RS::Sci {

    template <typename T>
    class UniformInteger {

    public:

        static_assert(std::is_integral_v<T>);

        using result_type = T;

        constexpr UniformInteger() noexcept {} // Defaults to 0-1
        constexpr explicit UniformInteger(T range) noexcept: min_(0), max_(range - 1) {} // 0 to range-1; UB if range<1
        constexpr UniformInteger(T a, T b) noexcept: min_(a), max_(b) {} // a to b inclusive; UB if a>b

        template <typename RNG>
        constexpr T operator()(RNG& rng) const noexcept {
            return generate(rng, min(), max());
        }

        constexpr T min() const noexcept { return min_; }
        constexpr T max() const noexcept { return max_; }

    private:

        T min_ = 0;
        T max_ = 1;

        template <typename RNG>
        constexpr static T generate(RNG& rng, T min, T max) noexcept {

            // We need an unsigned integer type big enough for both the RNG
            // and the output range.

            using output_range_type = std::make_unsigned_t<T>;
            using rng_result_type = typename RNG::result_type;
            using working_type = std::common_type_t<output_range_type, rng_result_type, unsigned>;

            if (min == max)
                return min;

            // Compare the input range (max-min of the values generated by the
            // RNG) with the output range (max-min of the possible results).

            auto rng_min = working_type(rng.min());
            auto rng_range = working_type(rng.max()) - rng_min;
            auto out_range = working_type(output_range_type(max) - output_range_type(min));
            working_type result;

            if (out_range < rng_range) {

                // The RNG range is larger than the output range. Divide the
                // output of the RNG by the rounded down quotient of the
                // ranges. If one range is not an exact multiple of the
                // other, this may yield a value too large; try again.

                working_type ratio = (rng_range - out_range) / (out_range + 1) + 1;
                working_type limit = ratio * (out_range + 1) - 1;
                do result = working_type(rng() - rng_min);
                    while (result > limit);
                result /= ratio;

            } else if (out_range == rng_range) {

                // The trivial case where the two ranges are equal.

                result = working_type(rng() - rng_min);

            } else {

                // The output range is larger than the RNG range. Split the
                // output range into a quotient and remainder modulo the RNG
                // range +1; call this function recursively for the quotient,
                // then call the RNG directly for the remainder. Try again if
                // the result is too large.

                working_type high = 0, low = 0;
                working_type ratio = (out_range - rng_range) / (rng_range + 1);
                do {
                    high = generate(rng, working_type(0), ratio) * (rng_range + 1);
                    low = working_type(rng() - rng_min);
                } while (low > out_range - high);
                result = high + low;

            }

            return min + T(result);

        }

    };

    class BernoulliDistribution {

    public:

        using result_type = bool;

        constexpr BernoulliDistribution() noexcept:
        BernoulliDistribution(1, 2) {}

        constexpr explicit BernoulliDistribution(double p) noexcept {
            constexpr int den = std::numeric_limits<int>::max();
            int num = int(std::lround(p * den));
            prob_ = {num, den};
        }

        constexpr explicit BernoulliDistribution(Rational p) noexcept:
        prob_(p) {}

        constexpr BernoulliDistribution(int num, int den) noexcept:
        prob_(Rational(num, den)) {}

        template <typename RNG>
        constexpr bool operator()(RNG& rng) const noexcept {
            return int_dist(prob_.den())(rng) < prob_.num();
        }

        constexpr Rational p() const noexcept { return prob_; }

    private:

        using int_type = Rational::integer_type;
        using int_dist = UniformInteger<int_type>;

        Rational prob_;

    };

    template <typename T>
    class DiscreteNormal {

    public:

        static_assert(std::is_integral_v<T>);

        using result_type = T;

        DiscreteNormal() = default; // Defaults to (0,1)
        DiscreteNormal(double mean, double sd) noexcept: norm_(mean, sd) {}

        template <typename RNG>
        T operator()(RNG& rng) const noexcept {
            return T(std::lround(norm_(rng)));
        }

        double mean() const noexcept { return norm_.mean(); }
        double sd() const noexcept { return norm_.sd(); }

    private:

        NormalDistribution<double> norm_;

    };

    template <typename T, typename U = double>
    class PoissonDistribution {

    public:

        static_assert(std::is_integral_v<T>);
        static_assert(std::is_floating_point_v<U>);

        using result_type = T;
        using scalar_type = U;

        PoissonDistribution() noexcept {}
        explicit PoissonDistribution(U lambda) noexcept: lambda_(lambda), log_lambda_(std::log(lambda)) {}

        template <typename RNG>
        T operator()(RNG& rng) const noexcept {

            // https://www.johndcook.com/blog/2010/06/14/generating-poisson-random-values/

            T n;
            UniformReal<U> unit;

            if (lambda_ <= 30) {

                // Knuth algorithm

                U xl = std::exp(- lambda_);
                T k = 0;
                U p = 1;

                do {
                    ++k;
                    U u = unit(rng);
                    p *= u;
                } while (p > xl);

                n = k - 1;

            } else {

                // Atkinson algorithm

                U c = U(0.767) - U(3.36) / lambda_;
                U beta = pi_c<U> / std::sqrt(3 * lambda_);
                U alpha = beta * lambda_;
                U k = std::log(c) - lambda_ - std::log(beta);
                U lhs, rhs;

                do {
                    U u = unit(rng);
                    U x = (alpha - std::log((1 - u) / u)) / beta;
                    n = T(std::floor(x + U(0.5)));
                    if (n < 0)
                        continue;
                    U v = unit(rng);
                    U y = alpha - beta * x;
                    U z = 1 + std::exp(y);
                    lhs = y + std::log(v / (z * z));
                    rhs = k + n * log_lambda_ - std::lgamma(U(n) + 1);
                } while (lhs > rhs);

            }

            return n;

        }

        U mean() const noexcept { return lambda_; }
        U sd() const noexcept { return std::sqrt(lambda_); }

    private:

        U lambda_ = 1;
        U log_lambda_ = 0;

    };

}
